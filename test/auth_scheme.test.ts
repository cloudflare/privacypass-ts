// Copyright (c) 2023 Cloudflare, Inc.
// Licensed under the Apache-2.0 license found in the LICENSE file or at https://opensource.org/licenses/Apache-2.0

import {
    AuthenticatorInput,
    TOKEN_TYPES,
    TokenChallenge,
    WWWAuthenticateHeader,
} from '../src/index.js';
import { hexToString, hexToUint8, testSerialize, uint8ToHex } from './util.js';

// Test vectors generated by pat-go (https://github.com/cloudflare/pat-go/)
// https://datatracker.ietf.org/doc/html/draft-ietf-privacypass-auth-scheme-14#name-test-vectors
import tokenVectors from './test_data/auth_scheme_token_v14.json';
import headerVectorsV14 from './test_data/auth_scheme_header_v14.json';
import headerVectorsComplicated from './test_data/auth_scheme_header_complicated.json';

type TokenVectors = (typeof tokenVectors)[number];

test.each(tokenVectors)('AuthScheme-TokenVector-%#', async (v: TokenVectors) => {
    const tokenType = parseInt(v.token_type);
    expect(tokenType).toBe(TOKEN_TYPES.BLIND_RSA.value);

    const issuerName = hexToString(v.issuer_name);
    const redemptionContext = hexToUint8(v.redemption_context);
    const originInfo = v.origin_info !== '' ? hexToString(v.origin_info).split(',') : undefined;
    const nonce = hexToUint8(v.nonce);
    const keyId = hexToUint8(v.token_key_id);

    const challenge = new TokenChallenge(tokenType, issuerName, redemptionContext, originInfo);
    const challengeSerialized = challenge.serialize();
    testSerialize(TokenChallenge, challenge);

    const context = new Uint8Array(await crypto.subtle.digest('SHA-256', challengeSerialized));
    const authInput = new AuthenticatorInput(
        TOKEN_TYPES.BLIND_RSA,
        TOKEN_TYPES.BLIND_RSA.value,
        nonce,
        context,
        keyId,
    );
    const authInputEnc = authInput.serialize();

    expect(uint8ToHex(authInputEnc)).toBe(v.token_authenticator_input);
});

const headerVectors = [...headerVectorsV14, ...headerVectorsComplicated];

type HeaderVectors = (typeof headerVectors)[number];

test.each(headerVectors)('AuthScheme-HeaderVector-%#', (v: HeaderVectors) => {
    const tokens = WWWAuthenticateHeader.parse(v['WWW-Authenticate']);

    let i = 0;
    for (const t of tokens) {
        expect(uint8ToHex(t.tokenKey)).toBe(v[`token-key-${i}` as keyof typeof v]);
        expect(t.challenge.tokenType).toBe(v[`token-type-${i}` as keyof typeof v]);
        expect(t.maxAge).toBe(v[`max-age-${i}` as keyof typeof v]);
        i += 1;
    }
});
